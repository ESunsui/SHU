# 数据库应用：基于MySQL

## 第一章 结构化查询语言SQL

​		结构化查询语言（Structured Query Language，SQL）是一种介于关系代数与关系演算之间的语言，其功能包括查询、操纵、定义和控制四个方面。SQL语言已经被定义为关系数据库系统（Relational Data Base System，RDBS）的国际标准（International Standard，IS）。

### 一、SQL概述

​	SQL数据库的体系结构为三级模式。具有以下特征：

- 一个SQL模式(*Schema*)是表和约束的集合。
- 一个表(*Table*)是行(*Row*)的集合。每行是列(*Column*)的序列，每列对应一个数据项。
- 一个表可以是一个基本表，也可以是一个视图。基本表是实际存储在数据库中的表。视图是从基本表或其他视图中导出的表，本身不独立存储在数据库中。*视图是一个虚表。*



​	SQL主要分为以下四个部分：

- 数据定义（SQL DDL, Data Defination Language）：定义SQL模式、基本表、视图和索引。
  - CREATE
  - DROP
  - ALTER

- 数据操纵（SQL DML, Data Management Language）：数据查询，数据更新。数据更新又分为插入、删除、修改。
  - SELECT
  - INSERT
  - DELETE
  - UPDATE

- 数据控制（SQL DCL, Data Control Language）：对基本表和视图的授权、完整性规则的描述、事务控制语句。
  - GRANT
  - REVOKE

- 嵌入式SQL。



### 二、SQL的数据定义

​		SQL的数据定义部分包括对SQL模式(*Schema*)，基本表(*Table*)，视图(*View*)，索引(*Index*)的创建和撤销操作。

#### 1、SQL模式的创建和撤销

一个SQL模式被定义为基本表的集合。创建了一个SQL模式就是定义了一个存储空间。

SQL模式的创建可以使用`CREATE`语句实现：	

```sql
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>
```

使用MySQL创建SQL模式：

```sql
CREATE DATABASE [IF NOT EXISTS] <数据库名> [DEFAULT CHARSET utf8 COLLATE utf8_general_ci];
```

执行结果为：创建指定名称的数据库，如果数据库不存在则创建，存在则不创建；并设定编码集为utf8。

当一个SQL模式及其所属的基本表、视图都不需要时，使用`DROP`语句撤销SQL模式。

```sql
DROP SCHEMA <模式名> [CASCADE|RESTRICT]
```

> CASCADE模式下，把SQL模式及其下属的基本表、视图、索引等元素全部删除
>
> RESTRICT模式下，只有SQL模式没有任何下属元素时才允许撤销SQL模式

使用MySQL删除SQL模式：

```sql
DROP DATABASE <数据库名>;
```

#### 2、SQL的基本数据类型

数值型

| 数据类型         | 解释                           |
| ---------------- | ------------------------------ |
| INTEGER          | 长整数                         |
| SMALLINT         | 短整数                         |
| REAl             | 浮点数                         |
| DOUBLE PRECISION | 双精度浮点数                   |
| FLOAT(n)         | 精度至少为n位数字的浮点数      |
| NUMERIC(p,d)     | 由p位数字，d位小数组成的浮点数 |

字符串型

| 数据类型   | 解释                    |
| ---------- | ----------------------- |
| CHAR(n)    | 长度为n的定长字符串     |
| VARCHAR(n) | 最大长度为n的变长字符串 |

位串型

| 数据类型       | 解释                        |
| -------------- | --------------------------- |
| BIT(n)         | 长度为n的定长二进制位串     |
| BIT VARYING(n) | 最大长度为n的变长二进制位串 |

时间型

| 数据类型 | 解释       |
| -------- | ---------- |
| DATE     | YYYY-MM-DD |
| TIME     | HH:MM:SS   |

#### 3、基本表的创建、修改和撤销

**基本表的创建**

创建基本表，就是定义基本表的结构。可以用`CREATE`语句实现。

```sql
CREATE TABLE [<模式名>] <表名> (<列名> <类型>, ..., [完整性约束])
```

完整性约束包括

- 主键子句`PRIMARY KEY`
- 检查子句`CHECK`
- 外键子句`FOREIGN KEY`

```sql
CREATE TABLE [<模式名>] <表名> (<列名> <类型>, ..., [PRIMARY KEY <列名>], [[CONSTRAINT <约束名>]CHECK <属性> BETWEEN val AND val], [FOREIGN KEY <列名> REFERENCES <表名>(<列名>)])
```

**基本表的修改**

增加新的属性

```sql
ALTER TABLE <表名> ADD <新属性名> [新属性完整性约束]
```

删除原有的属性

```sql
ALTER TABLE <表名> DROP <属性名> [CASCADE|RESTRICT]
```

增加约束

```sql
ALTER TABLE <表名> ADD CONSTRAINT <约束名> CHECK(<属性> BETWEEN val AND val)
```

删除约束

```sql
ALTER TABLE <表名> DROP <约束名>
```

**删除基本表**

```sql
DROP TABLE <表名> [CASCADE|RESTRICT]
```

#### 4、索引的创建和撤销

创建索引

```sql
CREATE [UNIQUE] INDEX <索引名> ON <表名> (<列名> [ASC|DESC])
```

撤销索引

```sql
DROP INDEX <索引名> ON <表名>
```



### 三、SQL的数据查询

#### 1、SELECT语句

SELECT语句的组成：

1. `SELECT`子句
2. `FROM`子句
3. `WHERE`子句（行条件语句）
4. `GROUP BY`子句（分组子句），`HAVING`子句（组条件子句）
5. `ORDER BY`子句（排序子句）

SELECT语句的句法和执行过程：

1. 读取`FROM`子句中基本表、视图的数据，执行笛卡尔积操作
2. 选取满足`WHERE`子句中给出条件的元组
3. 按`GROUP`子句中指定列的值分组，同时提取满足`HAVING`子句中组条件表达式的组
4. 按`SELECT`子句中给出的列名或列表达式求值输出
5. 按`ORDER`子句对输出的目标进行排序

#### 2、单表查询

**查询指定列**

```sql
SELECT <列名> FROM <表名>
```

**查询所有列**

```sql
SELECT * FROM <表名>
```

**查询不同值**

```sql
SELECT DISTINCT <列名> FROM <表名>
```

**比较**（`>, <, =, >=, <=, <>`）

```sql
SELECT <列名> FROM <表名> WHERE <属性> = <条件>
```

**条件**（`NOT, AND, OR`）

```sql
SELECT <列名> FROM <表名> WHERE <属性1> = <value1> AND <属性2> = <value2>
```

**确定范围**

```sql
SELECT <列名> FROM <表名> WHERE <属性> [NOT] BETWEEN <value1> AND <value2>
```

**确定集合**

```sql
SELECT <列名> FROM <表名> WHERE <属性> [NOT] IN <(集合)>
```

**涉及空值**

```sql
SELECT <列名> FROM <表名> WHERE <属性> IS [NOT] NULL
```

**字符查询、通配符，模糊匹配**（`%`任意匹配，`_`匹配一次）

```sql
SELECT <列名> FROM <表名> WHERE <属性> LIKE <%Pattern_>
```

**聚合函数**（用于`SELECT`子句）

```sql
COUNT([DISTINCT] *)           统计元组个数
COUNT([DISTINCT] <列名>)       统计某一列值的个数
SUM([DISTINCT] <列名>)         统计某一列总和
AVG([DISTINCT] <列名>)         统计某一列平均值
MAX([DISTINCT] <列名>)         统计某一列最大值
MIN([DISTINCT] <列名>)         统计某一列最小值
```

```sql
SELECT SUM([DISTINCT] <列名>) FROM <表名> WHERE <属性> = <条件>
```

**分组**

```sql
SELECT <列名>, <属性> FROM <表名> GROUP BY <属性>
```

> SQL规定，凡是分组`GROUP BY`使用的类名必须在`SELECT`子句中出现。
>
> 对于*SQL Server*，`SELECT`中出现的属性必须在`GROUP BY`中出现，但不代表一定要按此分组；对*MySQL*则无此规定。

```sql
SELECT <列名>， <属性1> FROM <表名> GROUP BY <属性1> HAVING <属性2> = <值>
```

**排序**（升序`ASC`，降序`DESC`）

```sql
SELECT <列名> FROM <表名> ORDER BY <属性>
SELECT <列名>，MAX([DISTINCT] <列名>) FROM <表名> ORDER BY 2 DESC
```

> 使用聚合函数作为排序依据时，可以使用其在`SELECT`子句中的位置作为参数。

#### 3、多表查询

联接操作，多表合并（内联接，外联接，交叉联接）

**自身联接**，查询一张表相同列的两个属性

```sql
SELECT <列名> FROM <表名> AS <别名1>，<表名> AS <别名2> WHERE <别名1>.主键 = <别名2>.主键 AND <别名1.属性> = <别名2.属性>
```

**复合条件联接**（有相同属性）

```sql
SELECT <表名.列名> FROM <表名1>，<表名2> WHERE <表名1.键> = <表名2.键> AND <表名1.属性> = 'value' AND <表名2.属性> = 'value'
```

**嵌套查询**  IN子查询（值 `IN` 集合，IN相当于$\in$）

```sql
SELECT <列名> FROM <表名> WHERE <属性> [NOT] IN (SELECT <列名> FROM <表名> WHERE <属性> = 'value')
```

**ANY,ALL比较子查询**

```sql
SELECT <列名> FROM <表名> WHERE <属性>=<条件> GROUP BY <属性> HAVING AVG(<属性>) > ALL (SELECT <列名> FROM <表名> WHERE <属性>=<条件>)
等同于
SELECT <列名> FROM <表名> WHERE <属性>=<条件> GROUP BY <属性> HAVING AVG(<属性>) > (SELECT MAX(<列名>) FROM <表名> WHERE <属性>=<条件>)
```

**EXISTS存在子查询**

```sql
SELECT <列名> FROM <表名1> WHERE <属性> [NOT] EXISTS (SELECT * FROM <表名2> WHERE <属性> = 'value' AND <表名1>.<属性>=<表名2>.<属性>)
等同于
SELECT <列名> FROM <表名1> WHERE <属性> [NOT] IN (SELECT <列名> FROM <表名2> WHERE <属性> = 'value')
```

> SQL语言不存在全称量词，使用全程需要转换为不存在不满足（双重否定）。
> $$
> (\forall x) P \equiv \neg (\exist x) \neg P
> $$

```sql
SELECT cno,cname FROM c WHERE NOT EXISTS (SELECT sno FROM s WHERE NOT EXISTS (SELECT * FROM sc WHERE sno=s.sno AND cno=c.cno))
```

> SQL不支持逻辑蕴含，使用需要转换。
> $$
> p \rightarrow q \equiv \neg p \lor q
> $$

求：所有选修 学号为S3的学生选修的课程 的学生的学号。

设p：S3选修课程，q：Sx选修课程。
$$
(\forall c_y) (p \rightarrow q) \\ \equiv \neg(\exist c_y) \neg(p \rightarrow q) \\ \equiv \neg(\exist c_y) \neg(\neg p \lor q) \\ \equiv \neg(\exist c_y) (p \land \neg q)
$$

```sql
SELECT sno FROM sc x WHERE NOT EXiSTS (SELECT * FROM sc y WHERE sno='s3' AND NOT EXISTS (SELECT FROM sc z WHERE sno=x.sno and cno=y.cno))
```



### 四、SQL的数据操纵

#### 1、数据插入

一次插入一行

```sql
INSERT INTO <表名> [<属性名>] VALUES (<元组值>)
```

一次插入多行

```sql
INSERT INTO <表名> [<属性名>] VALUES (<元组值>), (<元组值>), (<元组值>)...
```

子查询插入

```sql
INSERT INTO <表名> [<属性名>] (子查询)
```

#### 2、数据删除

删除满足条件的行

```sql
DELETE FROM <唯一表名> [WHERE <带子查询的条件表达式(IN)>]
DELETE FROM s WHERE sno NOT IN (SELECT sno FROM sc)
```

#### 3、数据修改

```sql
UPDATE <表名> SET <列名>=<表达式> [WHERE <带子查询的条件表达式>]
```

### 五、视图

视图的定义：

1. 视图是从一个或多个关系（基本表或已有的视图）导出的关系
2. 视图是虚表，数据库中只有视图的定义而无实际关系
3. 视图一经定义就可像基本表一样进行查询和更新

#### 1、视图的创建与删除

创建视图

```sql
CREATE VIEW <视图名> [<列名list>] AS <子查询> [WITH CHECK OPTION]
```

删除视图

```sql
DROP VIEW <视图名>
```

删除视图仅删除视图的定义，不删除相关数据。

#### 2、视图的查询

对视图的查询转换为对表的查询。

对视图的查询命令与基本表完全相同。

DBMS发现SELECT的查询对象为视图时，从数据字典中取出视图的定义，将视图定义的子查询与SELECT查询结合，生成等价的对基本表的查询（称作视图的消解）。

#### 3、视图的更新

对视图的更新由DBMS转化为对对应基本表的更新。

不是所有的视图都是可更新的，因为有些视图的更新无法有意义的转化为相应基本表的更新。

一般的DBMS只允许对单个基本表导出的视图进行更新，并有下列限制：

1. 视图的列由表达式或常数组成，不允许执行`INSERT`和`UPDATE`，可以执行`DELETE`
2. 视图的列由集合函数组成，不允许更新
3. 视图定义有`GROUP BY`子句，不允许更新
4. 视图定义中有`DISTINCT`选项，不允许更新
5. 视图定义中有嵌套查询，且内外层`FROM`子句中为同一个表，不允许更新
6. 从不允许更新的视图导出的表，不允许更新

#### 4、视图的优点

1. 方便用户操作
2. 对数据提供安全保护
3. 给数据共享提供便利

### 六、嵌入式SQL

#### 1、嵌入式SQL的使用规定

- 嵌入的SQL语句加前缀EXEC SQL
- DBMS与宿主语言之间的数据传递通过宿主语言程序变量实现，SQL引用主变量时，变量前应加 ':'
- SQL语言与宿主语言之间通过游标Cursor实现。Curser为一张表，是系统为用户开设的数据缓冲区，存放SQL的执行结果。

定义游标

```sql
EXEC SQL DECLARE <游标名> CURSOR FOR <SELECT语句>
```

打开游标

```sql
EXEC SQL OPEN <游标名>
```

推进游标

```sql
EXEC SQL FETCH <游标名> INTO <主变量名列表>
```

关闭游标

```sql
EXEC SQL CLOSE <游标名>
```

#### 2、嵌入式SQL的使用技术

不涉及游标的SQL语句

1. 嵌入式SQL中，DDL与DCL不需要使用游标，不需要返回数据，不使用主变量。
2. INSERT，DELETE，UPDATE不涉及游标。
3. SELECT语句的查询结果一定为单元组时，可以不使用游标。

涉及游标的SQL语句

1. SELECT语句查询结果为多个元组时，使用游标把多个元组一次一个的传送给宿主语言
2. 对游标指向的元组进行修改或删除

滚动游标的定义和推进

## 第二章 数据库发展史

### 一、数据管理技术的发展

#### 1、人工管理阶段

硬件方面：计算机运算速度低，内存容量小，没有直接存储的存储设备

软件方面：没有操作系统，没有管理数据的软件

1. 数据不保存在计算机内
2. 没有转用软件对数据进行管理
3. 只有程序概念，没有文件概念
4. 数据面向程序，数据与程序对应，不可重复使用

完全由程序员管理数据，管理物理结构、逻辑结构。

#### 2、文件系统阶段

硬件方面：有了磁盘

软件方面：有了操作系统，文件管理系统

1. 数据以文件形式长期保存在外部存储器上
2. 数据的逻辑结构与物理结构有了简单的区别
3. 文件组织已经多样化
4. 数据面向应用，不再属于某个特定的程序，可重复使用
5. 对数据的操作以记录为单位

**文件系统存在一定的缺陷：**

- 数据冗余：大量重复文件
- 不一致性：同样的数据在不同的文件中不一样
- 数据联系弱：文件之间相互独立，联系性弱

#### 2.5、倒排文件系统阶段

#### 3、数据库阶段

### 二、数据库技术的产生和发展

#### 1、数据库事件的产生

1. IMS系统(*1968,IBM*)：层次型数据库（树）
2. DBTG报告(*1969,CODASYL*)：网状数据库（图）
3. E.F.Codd的文章(*1970,IBM*)：关系型数据库（链表）

#### 2、数据库阶段的特点

1. 采用数据模型表示复杂的数据结构
2. 有较高的数据独立性（数据、程序分离，互不影响）
3. 方便的用户接口
4. 数据控制功能
5. 增加系统灵活性

程序与数据之间的联系通过DBMS实现

```flow
st=>start: 用户
op1=>operation: 接口
op2=>operation: DBMS
e=>end: 数据库

st(right)->op1(right)->op2(right)->e
```

#### 3、数据库技术的术语

1. 数据库DB
2. 数据库管理系统DBMS
3. 数据库技术
4. 数据库系统DBS

#### 4、数据库技术的发展

1. 分布式数据库
2. 面向对象数据库技术
3. 数据仓库
4. 云数据库
5. 大数据
6. 其他新型的数据库技术

## 第三章 数据库系统结构

### 一、数据描述

#### 1、概念设计中的数据描述

> 现实世界$\rightarrow$信息世界

实体：客观存在，可以相互区别的事物称为实体

实体集：性质相同的同类实体的集合

属性：实体的特性称为属性

实体标识符：能唯一标识实体的属性或属性集

#### 2、逻辑设计中的数据描述

> 信息世界$\rightarrow$机器世界

字段：标记实体属性的命名单位

记录：字段的有序集合

文件：同一类记录的集合

关键码：能唯一标识文件中每个记录的字段

#### 3、存储介质层次及数据描述

1、物理存储介质层次

高速缓存，主存储器，闪存，磁盘存储器，光存储器，磁带

2、物理存储中的数据描述

位，字节，字，块，桶，卷

#### 4、数据联系的描述

联系是实体之间的相互关系，实体并不是孤立静止存在的。

1. 二元联系
   1. 一对一联系 1:1
   2. 一对多联系 1:n
   3. 多对多联系 m:n
2. 三元关系
3. 一元关系

### 二、数据模型

数据模型分为两类：概念模型，结构模型。

概念模型：建立信息世界的数据模型

结构模型：直接面向数据库的数据模型

#### 1、实体联系模型

E-R图（Entity-Relationship，实体联系图），E-R方法

概念设计$\rightarrow$E-R图

![image-20211220133754109](img\image-20211220133754109.png)

与计算机无关

#### 2、层次模型

第一代数据库。用**树形结构**表示实体类型及实体间联系。记录之间的联系通过指针实现。

一般只能表示一对多模型。

#### 3、网状模型

第一代数据库。用**有向图结构**表示实体类型及实体间联系。记录之间的联系通过指针实现。

#### 4、关系模型

第二代数据库。用**表结构**表示实体类型及实体间联系。每个关系实际上是一张二维网格。记录之间的联系通过外键（公共属性）实现。

#### 5、其他模型

第三代数据库。包括面向对象模型，半结构化模型等。

### 三、数据库体系结构

#### 1、三级模式结构

- 外部级 外模式 [DBTG子模式]（单个用户的视图，用户的局部逻辑结构）
- 概念级 概念模式 [DBTG模式]（全局视图，数据库的整体逻辑结构）
- 内部级 内模式 [DBTG物理模式]（存储视图，数据库的物理结构）

三级结构之间差别往往很大，为实现三个抽象级别的联系与转换，三级结构之间提供两个层次映像，称二级映像。

![image-20211220133849609](img\image-20211220133849609.png)

#### 2、三级结构和两级映像

- 外模式：用户与DBS的接口，用户使用部分数据的描述
  - 外模式/模式映像：定义外模式和概念模式之间的对应性
- 概念模式：数据库中全部数据的整体逻辑结构的描述
  - 模式/内模式映像：定义概念模式和内模式之间的对应性
- 内模式：数据在物理存储方面的描述

#### 3、两级数据独立性

模式/内模式映象：当数据库的存储结构改变时，只要相应改变模式/内模式映象，可使模式保持不变。保证了数据的物理独立性。

外模式/模式映象：当数据库的概念模式改变时，只要相应改变外模式/模式映象，可使外模式保持不变。保证了数据的逻辑独立性。

#### 4、用户及用户界面

### 四、数据库管理系统

#### 1、DBMS的工作模式

对DB的一切操作，包括定义、查询、更新及各种控制都是通过DBMS进行。

DBMS的工作模式如下：

1. 接收应用程序的数据请求和处理请求
2. 将用户的数据请求转化为机器代码
3. 实现对数据库的操作
4. 从对数据库的操作中接收查询结果
5. 对查询结果进行处理
6. 将处理结果返回给用户

![image-20211220143530182](img\image-20211220143530182.png)

#### 2、DBMS的主要功能

1、数据定义功能

​	DBMS提供DDL来定义模式、外模式和内模式。

2、数据操纵功能

​	DBMS提供数据操纵语言（DML）供用户对数据库中的数据进行检索、修改、删除以及插入工作。

3、数据保护功能

​	数据库的恢复、并发控制、完整性、安全性。

4、数据维护功能

5、数据字典

#### 3、DBMS的模块组成

- 查询处理器
  - DDL编译器
  - DML编译器
  - 嵌入型DML的预编译器
  - 查询运行核心程序
- 存储管理器
  - 授权和完整性管理器
  - 事务管理器
  - 文件管理器
  - 缓冲区管理器


### 五、数据库系统

#### 1、数据库的组成

1、数据库

​	物理数据库，描述数据库

2、硬件

​	计算机硬件，存储设备

3、软件

​	DBMS，OS，各种宿主语言，开发支撑软件

4、数据库管理员

​	DBA，控制数据整体结构，负责DBS的正常运行

#### 2、DBS的全局结构

1、用户

​	DBA、专业用户、应用程序员、最终用户

2、DBMS的查询处理器

​	DML编译器、嵌入型DML的预编译器、DML编译器、查询运行核心程序

3、DBMS的存储管理器

​	授权和完整性管理器、事务管理器、文件管理器、缓冲区管理器。

4、磁盘存储器中的数据结构

​	数据文件、数据字典、索引文件、统计数据组织

#### 3、DBS系统结构的分类

1、集中式DBS

2、C/S式DBS

3、并行式DBS

4、分布式DBS

#### 4、DBS的效益

## 第四章 关系运算

### 一、关系数据模型

#### 1、关系数据模型的定义

关系运算是集合操作。操作的对象是集合，操作的结果也是集合。关系操作的基础是集合代数。

关系===表

> 定义1：域(Domain)是值的集合，表示属性的取值范围

> 定义2：关系是一个元数为k的元组的集合（集合论观点）。或关系是属性值笛卡尔积的一个子集（值域观点）。

> 定义3：关系的性质
>
> ​		1、列具有相同的性质，不同列可有相同的域
>
> ​		2、任意两个元组不能相同，元组的次序可交换
>
> ​		3、每个属性值都是不可分的数据项，属性值是最小单位

#### 2、关键码和表之间的关系

超键：在关系中能唯一标识元组的属性集称为超键

候选键：不含有多余属性的超键称为候选键

主键：用户选作元组标识符的候选键称为主键

外键：不是本关系的主键，但是另外一个关系的主键

#### 3、关系模式、关系子模式和存储模式

关系数据库遵守三级模式结构。

- 关系模式实际上是记录类型
- 关系子模式是关系模式的逻辑子集
- 存储模式是文件结构的描述

#### 4、关系模式的完整性规则

- 实体完整性规则：实体主键属性值不为空
- 参照完整性规则：不引用不存在的实体。外键值或为空，或为参照关系中的某个主键值
- 用户自定义完整性规则

#### 5、关系模式的形式定义

关系模型有三部分组成：

- 数据结构：关系。
- 数据操作：关系代数和关系演算
- 完整性规则：三类

### 二、关系代数

#### 1、关系查询语言和关系运算

关系数据库语言由查询语句（描述用户的检索操作）和更新语句（描述用户的插入、修改和删除等操作）两大类组成。

关系代数是通过对关系的运算来表达查询的。 它的运算对象是关系，运算结果也是关系。

关系运算理论分为关系代数和关系演算两种。

**关系查询语言分为：**

- 关系代数语言：以集合操作为基础；
- 关系演算语言：以谓词演算为基础； 元组关系演算语言和域关系演算语言；
- 基于关系代数和关系演算语言双重特点的语言： SQL

#### 2、关系代数的五个基本运算

关系代数是由一组**以关系作为运算对象**的特定的**运算符**组成，常用的运算为九种：并、交、差、笛卡尔积、联接、自然联接、投影、选择、除运算等，其中五种为基本运算：并、差、笛卡尔积、投影、选择运算。

1、并

任取元组t，当且仅当$t\in R$或$t\in S$时，$t\in R\cup S$
$$
R \cup S \equiv \left\{ t | t \in R \lor t \in S \right\}
$$
2、差

任取元组t，当且仅当$t\in R$且$t\notin S$时，$t\in R-S$
$$
R - S \equiv \left\{ t | t \in R \land t \notin S \right\}
$$
3、笛卡尔积

设R与S的元数为r与s，R和S的笛卡尔积$R\times S$是一个(r+s)元的元组集合，每个元组的前r个分量是R的一个元组，后s个分量是S的一个元组。
$$
R \times S \equiv \left\{ t | t = <t^r, t^s> \quad \land \quad t^r \in R \quad \land \quad t^s \in S \right\}
$$
4、投影

对一个关系进行垂直分割,消去某些列，并重新安排列的顺序,再删去重复元组。
$$
\Pi_{i_1, i_2, \dots, i_m} (R) \equiv \left\{ t | t = <t_{i_1}, t_{i_2}, \dots, t_{i_m}> \land <t_1, \dots, t_k> \in R \right\}
$$
5、选择

根据某些条件对关系做水平分割,选择符合条件的元组。选择运算是在一个关系中,选取符合某给定条件的全体元组,生成的新关系。
$$
\sigma_F(R) \equiv \left\{ t | t \in R \land F(t) \in True \right\}
$$

#### 3、关系代数的组合操作

6、交

任取元组t，当且仅当$t\in R$且$t\in S$时，$t\in R\cap S$
$$
R \cap S \equiv \left\{ t | t \in R \land t \in S \right\}
$$
关系的交可以由关系的差来表示
$$
R \cap S \equiv R - (R-S) \equiv S - (S-R)
$$
7、联接

联接操作是笛卡儿积、选择操作的组合。
$$
R \mathop{\Join} \limits_{A\theta B} S = \sigma_{A \theta B} (R \times S)
$$
8、自然联接

将关系R和S中公共属性组满足对应分量相等的元组联接起来， 并且在结果中把重复的属性去除
$$
R \Join S \equiv \Pi_{RemoveCommonAttributeFromS}(\sigma_{EqualCommonAttribute}(R \times S))
$$


9、除
$$
Assume \quad rank(R)=r, rank(S)=s, \quad r>s>0\\
R \div S \equiv \left\{ t | t<t,w> \in R \quad \land \quad w \in S \right\}
$$

#### 4、关系代数表达式

已知关系模式

    S（Sno，SName，Age，Sex），
    C（Cno，CName，Tname），
    SC（Sno，Cno，Grade）

1、求选修C2课程的学生号码。

$\Pi_{sno}(\sigma_{cno='c2'}(SC))$

2、求学生姓名为许军所读课程的课程号。

$\Pi_{cno}(\sigma_{sname='许军'}(S \Join SC))$

3、求选修刘老师所授课程的学生姓名

$\Pi_{sname}(\sigma_{tname='刘老师'}(S\Join SC\Join C))$

4、求不选修高等数学课程的学生号码（出现‘不’，使用差运算）

$\Pi_{sno}(S)-\Pi_{sno}(\sigma_{cname='高等数学'}(SC\Join C))$

5、求选修课程号为C2或C4的学生号码

$\Pi_{sno}(\sigma_{cno='C2' \lor cno='C4'}(SC))$

6、求选修课程号为C2和C4的学生号码（出现'和'，发生自联接，使用笛卡尔积）

$\Pi_1(\sigma_{1=4 \land 2='c2' \land 5='c4'}(SC \times SC))$

7、求选修全部课程的学生号码和姓名（出现‘全部’，使用除运算）

$\Pi_{sno,sname}((\Pi_{sno,cno}(SC)\div \Pi_{cno}(C))\Join S)$

8、求选修学号为S3的学生所修全部课程的学生号码

$\Pi_{sno,cno}(SC)\div \Pi_{cno}(\sigma_{sno='S3'}(SC))$

#### 5、扩充的关系代数操作

1、外联接⟗

在R与S做自然联接时，把原先舍弃的元组也保留在新关系中。新增加的属性值为null

2、左外联接⟕

在R与S做自然联接时，把原先R中舍弃的元组也保留在新关系中。新增加的属性值为null

3、右外联接⟖

在R与S做自然联接时，把原先S中舍弃的元组也保留在新关系中。新增加的属性值为null

4、外部并

如果R和S的关系模式不同，构成的新关系属性有R和S的所有属性组成（公共属性只取一次），新关系的元组由属于R或属于S的元组构成，同时元组在新增加的属性上填上空值。

5、半连接$\ltimes$

R和S的自然联接在关系R的属性集上的投影
$$
R \ltimes S \equiv \Pi_R(R \Join S)
$$

